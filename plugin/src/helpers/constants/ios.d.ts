export declare const LOCAL_PATH_TO_CIO_NSE_FILES: any;
export declare function getRelativePathToRNSDK(iosPath: string): any;
export declare const IOS_DEPLOYMENT_TARGET = "13.0";
export declare const GROUP_IDENTIFIER_TEMPLATE_REGEX: RegExp;
export declare const BUNDLE_SHORT_VERSION_TEMPLATE_REGEX: RegExp;
export declare const BUNDLE_VERSION_TEMPLATE_REGEX: RegExp;
export declare const CIO_DIDFINISHLAUNCHINGMETHOD_REGEX: RegExp;
export declare const CIO_DIDFAILTOREGISTERFORREMOTENOTIFICATIONSWITHERROR_REGEX: RegExp;
export declare const CIO_DIDFAILTOREGISTERFORREMOTENOTIFICATIONSWITHERRORFULL_REGEX: RegExp;
export declare const CIO_DIDREGISTERFORREMOTENOTIFICATIONSWITHDEVICETOKEN_REGEX: RegExp;
export declare const CIO_APPDELEGATEDECLARATION_REGEX: RegExp;
export declare const CIO_APPDELEGATEHEADER_REGEX: RegExp;
export declare const CIO_RCTBRIDGE_DEEPLINK_MODIFIEDOPTIONS_REGEX: RegExp;
export declare const CIO_LAUNCHOPTIONS_DEEPLINK_MODIFIEDOPTIONS_REGEX: RegExp;
export declare const CIO_DEEPLINK_COMMENT_REGEX: RegExp;
export declare const DEFAULT_BUNDLE_VERSION = "1";
export declare const DEFAULT_BUNDLE_SHORT_VERSION = "1.0";
export declare const CIO_TARGET_NAME = "CustomerIOSDK";
export declare const CIO_NOTIFICATION_TARGET_NAME = "NotificationService";
export declare const CIO_APPDELEGATEHEADER_IMPORT_SNIPPET = "#import <UserNotifications/UserNotifications.h>";
export declare const CIO_APPDELEGATEHEADER_USER_NOTIFICATION_CENTER_SNIPPET = "UNUserNotificationCenterDelegate";
export declare const CIO_PUSHNOTIFICATIONHANDLERDECLARATION_SNIPPET = "\nCIOAppPushNotificationsHandler* pnHandlerObj = [[CIOAppPushNotificationsHandler alloc] init];\n";
export declare const CIO_RCTBRIDGE_DEEPLINK_MODIFIEDOPTIONS_SNIPPET = "\nRCTBridge *bridge = [self.reactDelegate createBridgeWithDelegate:self launchOptions:modifiedLaunchOptions];\n";
export declare const CIO_LAUNCHOPTIONS_MODIFIEDOPTIONS_SNIPPET = "\nreturn [super application:application didFinishLaunchingWithOptions:modifiedLaunchOptions];";
export declare const CIO_DIDFAILTOREGISTERFORREMOTENOTIFICATIONSWITHERROR_SNIPPET = "\n  [super application:application didFailToRegisterForRemoteNotificationsWithError:error];\n  [pnHandlerObj application:application error:error];\n";
export declare const CIO_DIDREGISTERFORREMOTENOTIFICATIONSWITHDEVICETOKEN_SNIPPET = "\n  [super application:application didRegisterForRemoteNotificationsWithDeviceToken:deviceToken];\n  return [pnHandlerObj application:application deviceToken:deviceToken];\n";
export declare const CIO_CONFIGURECIOSDKPUSHNOTIFICATION_SNIPPET = "\n  // Register for push notifications\n  [pnHandlerObj registerPushNotification];\n";
export declare const CIO_INITIALIZECIOSDK_SNIPPET = "  \n  [pnHandlerObj initializeCioSdk];\n\n// Code to make the CIO SDK compatible with expo-notifications package.\n// \n// The CIO SDK and expo-notifications both need to handle when a push gets clicked. However, iOS only allows one click handler to be set per app.\n// To get around this limitation, we set the CIO SDK as the click handler. The CIO SDK sets itself up so that when another SDK or host iOS app \n// sets itself as the click handler, the CIO SDK will still be able to handle when the push gets clicked, even though it's not the designated \n// click handler in iOS at runtime. \n// \n// This should work for most SDKs. However, expo-notifications is unique in it's implementation. It will not setup push click handling it if detects \n// that another SDK or host iOS app has already set itself as the click handler:\n// https://github.com/expo/expo/blob/1b29637bec0b9888e8bc8c310476293a3e2d9786/packages/expo-notifications/ios/EXNotifications/Notifications/EXNotificationCenterDelegate.m#L31-L37\n// ...to get around this, we must manually set it as the click handler after the CIO SDK. That's what this code block does.\n//\n// Note: Initialize the native iOS SDK and setup SDK push click handling before running this code. \n# if __has_include(<EXNotifications/EXNotificationCenterDelegate.h>)\n  // Creating a new instance, as the comments in expo-notifications suggests, does not work. With this code, if you send a CIO push to device and click on it,\n  // no push metrics reporting will occur.\n  // EXNotificationCenterDelegate *notificationCenterDelegate = [[EXNotificationCenterDelegate alloc] init];\n\n  // ...instead, get the singleton reference from Expo. \n  id<UNUserNotificationCenterDelegate> notificationCenterDelegate = (id<UNUserNotificationCenterDelegate>) [EXModuleRegistryProvider getSingletonModuleForClass:[EXNotificationCenterDelegate class]];\n  UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];\n  center.delegate = notificationCenterDelegate;\n# endif\n";
export declare const CIO_CONFIGUREDEEPLINK_KILLEDSTATE_SNIPPET = "\n// Deep link workaround for app killed state start\nNSMutableDictionary *modifiedLaunchOptions = [NSMutableDictionary dictionaryWithDictionary:launchOptions];\n  if (launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey]) {\n      NSDictionary *pushContent = launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey];\n      if (pushContent[@\"CIO\"] && pushContent[@\"CIO\"][@\"push\"] && pushContent[@\"CIO\"][@\"push\"][@\"link\"]) {\n        NSString *initialURL = pushContent[@\"CIO\"][@\"push\"][@\"link\"];\n          if (!launchOptions[UIApplicationLaunchOptionsURLKey]) {\n              modifiedLaunchOptions[UIApplicationLaunchOptionsURLKey] = [NSURL URLWithString:initialURL];\n          }\n      }\n  }\n//Deep link workaround for app killed state ends\n";
export declare const CIO_REGISTER_PUSHNOTIFICATION_SNIPPET = "\n@objc(registerPushNotification)\n  public func registerPushNotification() {\n\n    let center  = UNUserNotificationCenter.current()\n    center.requestAuthorization(options: [.sound, .alert, .badge]) { (granted, error) in\n      if error == nil{\n        DispatchQueue.main.async {\n          UIApplication.shared.registerForRemoteNotifications()\n        }\n      }\n    }\n  }";
export declare const CIO_APP_PUSH_NOTIFICATIONS_HANDLER_REGEX: RegExp;
export declare const CIO_APP_PUSH_NOTIFICATIONS_HANDLER_SNIPPET = "var pnHandlerObj = CIOAppPushNotificationsHandler()";
export declare const CIO_INITIALIZE_SDK_REGEX: RegExp;
export declare const CIO_INITIALIZE_SDK_SNIPPET = "\n    pnHandlerObj.registerPushNotification()\n    pnHandlerObj.initializeCioSdk()\n    \n    \n#if canImport(EXNotifications)\n    // Creating a new instance, as the comments in expo-notifications suggest, does not work.\n    // With this code, if you send a CIO push to device and click on it,\n    // no push metrics reporting will occur.\n    // let notificationCenterDelegate = EXNotificationCenterDelegate()\n\n    // \u2026instead, get the singleton reference from Expo.\n    if let notificationCenterDelegate =  Expo.ModuleRegistryProvider\n      .getSingletonModule(for: Expo.UNUserNotificationCenterDelegate.self)\n        as? UNUserNotificationCenterDelegate\n    {\n        let center = UNUserNotificationCenter.current()\n        center.delegate = notificationCenterDelegate\n    }\n#endif";
export declare const CIO_OVERRIDE_REMOTE_NOTIFICATION_REGEX: RegExp;
export declare const CIO_OVERRIDE_REMOTE_NOTIFICATION_SNIPPET = "\n  public override func application(_ application: UIApplication,\n                            didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Data) {\n      super.application(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken)\n    pnHandlerObj.application(application, didRegisterForRemoteNotificationsWithDeviceToken: deviceToken)\n  }\n \n  public override func application(_ application: UIApplication,\n                            didFailToRegisterForRemoteNotificationsWithError error: Error) {\n      super.application(application, didFailToRegisterForRemoteNotificationsWithError: error)\n    pnHandlerObj.application(application, didFailToRegisterForRemoteNotificationsWithError: error)\n  }\n  \n  // Explicitly define remote notification delegates to ensure compatibility with some third-party libraries\n  public override func application(_ application: UIApplication,\n                            didReceiveRemoteNotification userInfo: [AnyHashable: Any],\n                            fetchCompletionHandler completionHandler: @escaping (UIBackgroundFetchResult) -> Void) {\n      super.application(application,\n                        didReceiveRemoteNotification: userInfo,\n                        fetchCompletionHandler: completionHandler)\n  }";
